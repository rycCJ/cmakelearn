
# map[nums[i]] = i;
这行代码的意思是：将数组中的数值 nums[i] 作为键，将该数值的索引 i 作为值，存入到哈希表 map 中。
* 为什么必须这样设置？
这和我们的“目标”有关。我们的目标是：对于当前遍历到的数 nums[i]，我们需要快速查找**“它的另一半”（complement）是否存在**。
*  我们需要查找的是什么？
是一个数值。
* 查找的工具是什么？ 
是哈希表 map。
* 哈希表最擅长做什么？ 
根据键来快速查找。
所以，我们必须把要查找的数值本身作为“键”，这样才能利用哈希表 O(1) 的超高查询效率。
---

# unordered_map &vs& map

使用unordered_map最核心的原因有两个：1. 查询速度更快；2. 我们不需要对元素进行排序。

下面我们来逐一分析：

## 1. 内部结构与查询速度
这两种“map”的底层实现是完全不同的，这直接决定了它们的性能。

* unordered_map (可以理解为“无序的字典”)

内部结构：它的底层是一个哈希表（Hash Table）。

工作原理：当你存入一个键值对（比如，键是 12，值是 0）时，它会通过一个“哈希函数”直接计算出这个键应该存放的内存位置。下次你再来查找键 12 时，它用同样的函数一算，就能立刻定位到那个位置。

性能：这个过程非常快，平均来说，不管 unordered_map 里存了10个元素还是100万个元素，查询、插入和删除操作的时间都基本不变。我们称之为 O(1) 或“常数时间”复杂度。

* map (可以理解为“有序的字典”)

内部结构：它的底层是一棵红黑树（Red-Black Tree），这是一种非常复杂的、能自我保持平衡的二叉搜索树。

工作原理：树中的所有元素都是按键排序的。当你查找一个键时，程序需要从树的根节点开始，通过一系列的比较（比当前节点大就往右走，小就往左走），一步步“走”到目标位置。

性能：虽然这个查找过程也很快，但随着元素数量（N）的增加，查找需要经过的“步数”也会缓慢增加。我们称之为 O(log N) 或“对数时间”复杂度。

结论：在速度上，O(1) 远远快于 O(log N)。对于“两数之和”这类需要频繁查询“某个数是否存在”的问题，unordered_map 提供的闪电般的查询速度是它最大的优势。

## 2. 排序特性
* unordered_map：从名字就能看出，它是“无序的”。当你遍历它里面的元素时，元素的顺序是乱的，没有任何保证。

* map：它最大的特点就是“有序”。无论你何时遍历它，里面的元素总是严格按照键（Key）从小到大的顺序排列好的。

结论：在“两数之和”的问题中，我们只关心“目标数是否存在”以及“它的索引是什么”，完全不需要这些数字在我们的查询工具里排好序。map 为了维持排序所付出的性能代价，在这里是完全不必要的。

## 总结
| 特性	| unordered_map (无序哈希) |	map (有序红黑树)	| 在“两数之和”问题中的选择 |
| --- |  --- |  ---  | --- | 
| **查询速度** |  极快 (O(1))	 | 较快 (O(log N))	| 选 unordered_map |
| **元素排序** | 无序	| 按键自动排序 | 选 unordered_map (因为不需要排序) |

就像你要查一个单词的意思，一本按字母顺序排列的厚重词典（map）虽然好，但如果你有一个能瞬间告诉你单词在哪一页的魔法索引（unordered_map），你肯定会用这个魔法索引，因为它更快，而且你只是为了查单词，并不需要同时浏览它前后的单词。

因此，对于追求最高效率的算法问题（如“两数之和”），unordered_map 是标准且最佳的选择。

---
# find() 函数来检查键是否存在  
> 
find() 函数的作用是在 map（包括 unordered_map 和 map）中查找一个键（key）。

如果找到了这个键，find() 会返回一个指向该元素的迭代器（iterator）。

如果没找到这个键，find() 会返回一个特殊的迭代器，这个迭代器指向 map 的“末尾之后”的位置，我们用 map.end() 来表示它。

所以，判断一个键是否存在的逻辑就变成了：
调用 find() 函数，然后检查它返回的结果是不是等于 map.end()。

> find() 和 count() 的对比

| 方法 | 作用 |	优点|	缺点 |
| ---| --- | --- | --- |  
| **count(key)** |	返回键 key 出现的次数。在 map 或 unordered_map 中，由于键是唯一的，返回值只可能是 0 或 1 |	代码简洁：if (map.count(key)) 读起来就像“如果map里有这个key”。非常直观。 |	功能单一，只能判断“有”或“没有”。|
| **find(key)** |	查找键 key，并返回一个指向它的迭代器。	| 功能更强大：一旦找到了，可以直接通过返回的迭代器去访问那个元素的值（例如 it->second），避免了二次查找。| 代码稍微长一点：if (map.find(key) != map.end())。|

---
